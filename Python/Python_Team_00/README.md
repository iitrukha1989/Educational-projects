# Групповой, учебный проект 00 - Python Bootcamp

## Contents

1. [Chapter I](#chapter-i) \
    1.1. [EX00](#ex00)
2. [Chapter II](#chapter-ii) \
    2.1. [EX01](#ex01)
3. [Chapter III](#chapter-iii) \
    3.1. [EX02](#ex02)

## Chapter I
### EX00

Нужно написать скрипт с именем `cache_wiki.py`, основной целью которого будет загрузка страниц из Википедии, 
но интересующие нас данные — это ссылки в тексте и разделы `См. также`, ведущие на другие страницы. 
Это означает, что вам не нужно загружать содержимое, а нужно только сохранить представление графа в виде файла `JSON wiki.json`, 
чтобы вершины хранили страницы, а направленные ребра были ссылками.

Вы можете выбрать любую статью из Википедии в качестве начальной позиции по умолчанию. Кроме того, ваш код должен иметь 
возможность получать имя существующей статьи в качестве аргумента для использования вместо имени по умолчанию. 

Итак, когда он запускается следующим образом:
`python cache_wiki.py -p 'Erdős number'`

он должен начать синтаксический анализ с этой страницы . Обратите внимание на специальную кодировку символов в URL.
Цель состоит в том, чтобы продолжать переходить по ссылкам по крайней мере на три страницы вглубь каждой ссылки. Этот параметр можно настроить с помощью 
`-d`, поэтому значение по умолчанию будет 3. Но если результат слишком велик (>1000 страниц), ваш код должен перестать 
обрабатывать ссылки.

Каждая страница, которую посещает ваш код, должна быть зарегистрирована в стандартном выводе с использованием `logging`
модуля `Python` с уровнем журнала, установленным на `INFO`.

Нет строгих требований к формату файла `JSON`, создаваемого вашим кодом, но имейте в виду, что вам нужно будет 
поработать с этим файлом в следующих упражнениях, поэтому вы можете рассмотреть возможность использования существующих 
библиотек `Python` для обработки графов, которые поддерживают чтение/запись. `JSON-файлы`.

## Chapter II
### EX01

Теперь необходимо написать программу с именем `shortest_path.py`, которая должна будет найти кратчайшую 
длину пути между двумя страницами в вашей сериализованной базе данных (если эти страницы там есть):

Местоположение вики-файла должно быть прочитано из переменной среды с именем `WIKI_FILE`.
Кроме того, добавьте `-v` флаг, который позволит регистрировать найденный путь, например:

```
~$ python shortest_path.py -v --from 'Welsh Corgi' --to 'Solomon'
'Welsh Corgi' -> 'Dog training' -> 'King Solomon's Ring (book)' -> 'Solomon'
3
```

## Chapter III
### EX02

Ваш следующий скрипт `render_graph.py` должен визуализировать ваш график страниц (из файла, сгенерированного в EX00, 
а также считывая его из `WIKI_FILE` переменной `env`) в виде изображения `PNG` `wiki_graph.png` с узлами и краями. 
Для этого вы можете использовать любую стороннюю библиотеку.

Главное правило здесь — размер узла должен соответствовать количеству входящих подключений. 
Чем больше соединений - тем крупнее узел в рендере. Таким образом, «самые большие страницы» в вашем наборе данных 
будут лучше всего видны.
